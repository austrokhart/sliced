# Sliced Design 🌈

> Життя переможе смерть, а світ – темряву. 🇺🇦

**Sliced Design** — новый подход к разработке **файловой структуры** проектов на JavaScript. Облегчает разработку и поддержку проектов.

> **Перевод на другие языки**
>
> Если у вас есть возможность, пожалуйста, внесите вклад и помогите перевести этот документ на другие языки!

## Содержание

1. [Неудачно организованная файловая структура — это проблема](#неудачно-организованная-файловая-структура--это-проблема)
1. [У текущих подходов к организации есть существенные недостатки](#у-текущих-подходов-к-организации-есть-существенные-недостатки)
    - [Folders-by-type](#folders-by-type)
    - [Folders-by-feature](#folders-by-feature)
    - [Вложенность тоже не решает проблемы](#вложенность-тоже-не-решает-проблемы)
1. [Решение — Sliced Design](#решение--sliced-design)
1. [Быстрый старт](#быстрый-старт)
    - [Краткий обзор](#краткий-обзор)
    - [Применяем шаг за шагом](#применяем-шаг-за-шагом) 🔥
    - [Пример проекта](#пример-проекта)
1. [Методология](#методология)
    - [Категория](#категория)
      - [Расположение категорий](#расположение-категорий)
      - [Подкатегории](#подкатегории)
      - [Ограничения категорий](#ограничения-категорий)
      - [Мета-категории](#мета-категории)
    - [Группа](#группа)
      - [Расположение групп](#расположение-групп)
      - [Подгруппы](#подгруппы)
      - [Ограничения групп](#ограничения-групп)
      - [Мета-группы](#мета-группы)
    - [Элемент](#элемент)
      - [Расположение элементов](#расположение-элементов)
      - [Связи модулей внутри элемента-директории](#связи-модулей-внутри-элемента-директории)
      - [Ограничения элементов](#ограничения-элементов)
    - [Ресурс](#ресурс)
    - [Общие рекомендации](#общие-рекомендации)
1. [FAQ](#faq)
1. [Обратная связь](#обратная-связь)
1. [Контрибьюторы](#контрибьюторы)

## Неудачно организованная файловая структура — это проблема

Любой проект — это коллекция программного кода. По мере развития проекта, растёт **объём** этого кода и **сложность** его поддержки.

То, как будет расти сложность поддержки, во многом зависит от принимаемых во время разработки решений.

Если принимать решения **ситуативно**, сложность будет расти неконтролируемо и, скорее всего, стремительно. В то же время, если найти оптимальные подходы, разработать **систему** правил и придерживаться её, рост сложности можно контролировать.

Одна из самых сложных задач при работе с проектами — работа с **модулями**, понимание их **назначения** и **связей** между ними.

Для того, чтобы упростить понимание, при работе с **кодом** придерживаются принятой в проекте **архитектуры** и **соглашений**, которые соотносятся с популярными паттернами, практиками и индивидуальным опытом.

Но код не может сущестовать сам по себе. Для того, чтобы стать частью проекта, он должен быть помещён в **файл**. Файлы образуют файловую структуру. В ней **имя** и **принадлежность** к директории помогают понять **назначение** файла и **связи** с другими файлами.

Поскольку большинство файлов в проектах — модули, *неудачно организованная* файловая структура **усложняет работу с модулями**, понимание их **назначения** и **связей** между ними.

## У текущих подходов к организации есть существенные недостатки

Можно выделить два популярных подхода для организации файловой структуры: 

- [**folders-by-type**](#folders-by-type)
- [**folders-by-feature**](#folders-by-feature)

### Folders-by-type

Этот подход предусматривает группировку файлов по принадлежности к типу.

Для примера, файловая структура приложения на React может выглядеть так:

> ```
> src
> |-- api
> |-- assets
> |-- components
> |-- contexts
> |-- helpers
> |-- hooks
> |-- values
> ```

Файлы, относящиеся к компонентам, размещаются в `components`, к хелперам — в `helpers`, к значениям — в `values` и т.д.

Подход достаточен в небольших проектах, но при большом количестве файлов возникают **проблемы**:

- **Сложно ориентироваться, сложные имена файлов**

  > ```
  > components
  > |-- (15 файлов, начинающихся с префикса "app")
  > |-- (10 файлов, начинающихся с префикса "emoji")
  > |-- (20 файлов, начинающихся с префикса "home")
  > |-- (10 файлов, начинающихся с префикса "layout")
  > |-- (30 файлов, начинающихся с префикса "post")
  > |-- (20 файлов, начинающихся с префикса "post-editor")
  > |-- (15 файлов, начинающихся с префикса "trends")
  > |-- ...
  > ```

  Поскольку в среднем или большом проекте группа может содержать сотни файлов, возникают длинные списки, в которых может быть **сложно ориентироваться**.
  
  Чтобы избежать коллизий имён, к именам файлов или директорий добавляют префиксы. Такие имена может быть **неудобно читать** и **обращаться к ним**.

- **Сложно понять принадлежность файла к определённой бизнес-функции**

  Поскольку файлы сгруппированы только по типу, понять, какие из них относятся к определённой бизнес-функции, чаще всего возможно только **через изучение кода**.

### Folders-by-feature

Подход предусматривает группировку файлов по принадлежности к бизнес-функции.

> ```
> src
> |-- app
> |-- emoji
> |-- home
> |-- layout
> |-- post
> |-- trends
> ```

Файлы, относящиеся к домашней странице, размещаются в `home`, к постам — в `post` и т.д.

Этот подход решает основную проблему подхода **folders-by-type** (отсутствие группировки по принадлежности к бизнес-функции), но при большом количестве файлов тоже возникают **проблемы**:

- **Сложно ориентироваться**

  > ```
  > src
  > |-- post
  > |   |-- actions-like.jsx
  > |   |-- actions-like.styles.js
  > |   |-- actions-reply.jsx
  > |   |-- actions-reply.styles.js
  > |   |-- actions-repost.jsx
  > |   |-- actions-repost.styles.js
  > |   |-- actions-share.jsx
  > |   |-- actions-share.styles.js
  > |   |-- content-image.jsx
  > |   |-- content-image.styles.jsx
  > |   |-- content-text.jsx
  > |   |-- content-text.styles.js
  > |   |-- content-video.jsx
  > |   |-- content-video.styles.js
  > |   |-- content.jsx
  > |   |-- content.styles.js
  > |   |-- image-viewer-backdrop.jsx
  > |   |-- image-viewer-backdrop.styles.js
  > |   |-- image-viewer-navigation.jsx
  > |   |-- image-viewer-navigation.styles.js
  > |   |-- image-viewer.jsx
  > |   |-- image-viewer.styles.js
  > |   |-- post.jsx
  > |   |-- post.styles.js
  > |   |-- views.jsx
  > |   |-- views.styles.js
  > |
  > |-- post-editor
  > |   |-- audience.jsx
  > |   |-- audience.styles.js
  > |   |-- editor.jsx
  > |   |-- editor.styles.js
  > |   |-- emoji.jsx
  > |   |-- emoji.styles.js
  > |   |-- media.jsx
  > |   |-- media.styles.js
  > |   |-- poll.jsx
  > |   |-- poll.styles.js
  > |   |-- post-limits.constants.js
  > |   |-- settings.jsx
  > |   |-- settings.styles.js
  > |   |-- text-area.jsx
  > |   |-- text-area.styles.js
  > |
  > |-- ...
  > ```

  Поскольку в среднем или большом проекте группа может содержать десятки файлов и они **смешанного типа**, это **значительно** усложняет ориентирование. При просмотре директории мы знаем, что файлы относятся к определённой бизнес-функции, но нам сложно понять, **какого они типа** и **сколько их**.

⬆️ [К содержанию](#содержание)

### Вложенность тоже не решает проблемы

Вложенность решает проблему коллизий имён, но **значительно ухудшает** понимание связи между модулями, поскольку некоторые части проекта **не видны**, пока не раскрыть все вложенные директории.

> ```
> # изучим директорию `post` 👀
>
> src
> |-- post
> |-- ...
> ```
>
> ```
> # с виду довольно просто, но есть несколько вложенных директорий
>
> src
> |-- post
> |   |-- actions
> |   |-- content
> |   |-- image-viewer
> |   |-- post.jsx
> |   |-- post.styles.js
> |   |-- views.jsx
> |   |-- views.styles.js
> |-- ...
> ```
>
> ```
> # упс!
>
> src
> |-- post
> |   |-- actions
> |   |   |-- like.jsx
> |   |   |-- like.styles.js
> |   |   |-- reply.jsx
> |   |   |-- reply.styles.js
> |   |   |-- repost.jsx
> |   |   |-- repost.styles.js
> |   |   |-- share.jsx
> |   |   |-- share.styles.js
> |   |-- content
> |   |   |-- content.jsx
> |   |   |-- content.styles.js
> |   |   |-- image.jsx
> |   |   |-- image.styles.jsx
> |   |   |-- text.jsx
> |   |   |-- text.styles.js
> |   |   |-- video.jsx
> |   |   |-- video.styles.js
> |   |-- image-viewer
> |   |   |-- backdrop.jsx
> |   |   |-- backdrop.styles.js
> |   |   |-- image-viewer.jsx
> |   |   |-- image-viewer.styles.js
> |   |   |-- navigation.jsx
> |   |   |-- navigation.styles.js
> |   |-- post.jsx
> |   |-- post.styles.js
> |   |-- views.jsx
> |   |-- views.styles.js
> |-- ...
> ```

⬆️ [К содержанию](#содержание)

## Решение — Sliced Design

**Sliced Design** — новый подход к разработке **файловой структуры** проектов. Он вводит систему терминов ([категории](#категория), [группы](#группа), [элементы](#элемент)) и правил, чтобы облегчить разработку и поддержку проектов на JavaScript.

Преимущества **Sliced Design**:

- подходит для проектов **любой** сложности 🚀
- облегчает разработку и поддержку проектов 👩‍🔧
- легко понять и использовать, простые термины и правила ✌️
- группирует файлы по принадлежности к бизнес-функции и типу одновременно 📦
- упрощает понимание связей между файлами 🎇
- решает проблему коллизий имён файлов 🪆
- обеспечивает фиксированную вложенность директорий во всём проекте — максимум 3 уровня 📌

## Быстрый старт

### Краткий обзор

Файловая структура проекта на React, разработанная с применением подхода **Sliced Design**, может выглядеть так:

- в `src` содержатся [**категории**](#категория), они группируют [**элементы**](#элемент) (файлы) **по бизнес-функции**

  > ```
  > # в примере ниже
  > # `app`, `emoji`, `home`, `layout` и т.д. - категории
  >
  > src
  > |-- app
  > |   |-- ...
  > |-- emoji
  > |   |-- ...
  > |-- home
  > |   |-- ...
  > |-- layout
  > |   |-- ...
  > |-- post
  > |   |-- ...
  > |-- post.image-viewer
  > |   |-- ...
  > |-- post@shared
  > |   |-- ...
  > |-- post-editor
  > |   |-- ...
  > |-- trends
  > |   |-- ...
  > |-- ui-kit
  >     |-- ...
  > ```

- в **категориях** содержатся [**группы**](#группа), они группируют [**элементы**](#элемент) (файлы) **по типу**

  > ```
  > # в примере ниже
  > # `layout` - категория, а `components` и `helpers` - группы
  >
  > src
  > |-- layout
  > |   |-- components
  > |   |   |-- ...
  > |   |-- helpers
  > |   |   |-- ...
  > |   |-- index.js
  > |-- ...
  > ```

- [**элементы**](#элемент) могут быть **файлами** или **директориями с файлами**

  > ```
  > # в примере ниже
  > # `layout` - категория, `helpers` - группа, а `scroll.js` - элемент
  >
  > src
  > |-- layout
  > |   |-- helpers
  > |   |   |-- scroll.js
  > |   |   |-- ...
  > |   |-- ...
  > |-- ...
  > ```
  >
  > ```
  > # в примере ниже
  > # `layout` - категория, `components` - группа, а `navigation` - элемент
  > 
  > src
  > |-- layout
  > |   |-- components
  > |   |   |-- navigation
  > |   |   |   |-- component.jsx
  > |   |   |   |-- index.js
  > |   |   |   |-- styles.js
  > |   |   |-- ...
  > |   |-- ...
  > |-- ...
  > ```

Посмотреть полный пример файловой структуры проекта можно [здесь](#пример-проекта).

⬆️ [К содержанию](#содержание)

### Применяем шаг за шагом

Представим, что мы *фронтенд-разработчик с опытом разработки приложений на React* и нас пригласили на работу в проект, где разрабатывается новая социальная сеть.

Проект на самом раннем этапе разработки. Мы оказались в роли ведущего разработчика и нам предстоит инициализировать проект фронтенда.

#### Инициализируем приложение

> *Здесь мы создаём первые **категорию**, **группу** и **элемент**, знакомимся с ограничением на **доступ к внутренним ресурсам** категорий.*

Мы инициализировали новый репозиторий и собираемся добавить наши первые файлы.

Начнём работу с создания корневого компонента и инициализации приложения.

Для начала создадим в `src` [категорию](#категория) `app`.

> **Категория** — это директория, которая применяется для группировки файлов по бизнес-функции.

В категории `app` создадим [группу](#группа) `components`.

> **Группа** — это директория, которая применяется для группировки файлов по типу.

В группе `components` создадим [элемент](#элемент) `app`. 

> **Элемент** — это файл или директория с файлами, в нём размещается код.

В элементе `app` создадим модуль `component.jsx` с кодом компонента и модуль `index.js`, который реэкспортирует компонент из модуля `component.jsx`.

Получим такую структуру:

> ```
> src
> |--app
>    |-- components
>        |-- app
>            |-- component.jsx
>            |-- index.js
> ```

> **Важно!** **Sliced Design** определяет структуру вашего проекта, но не имена файлов и директорий. Все имена выбираете вы сами, исходя из популярных практик, соглашений  и индивидуального опыта.

Теперь создадим модуль с кодом инициализации, который будет монтировать наш корневой компонент. Он тоже относится к категории `app`, но к группе `effects`.

> ```
> src
> |--app
>    |-- components
>    |   |-- app
>    |       |-- component.jsx
>    |       |-- index.js
>    |-- effects
>        |-- init-app.js
> ```

Далее нам нужно указать путь к модулю инициализации в нашем сборщике модулей.

Мы могли бы указать путь `src/app/effects/init-app.js`, но нужно учесть следующее: у категорий существует [ограничение](#ограничения-категорий) на доступ к их внутренним ресурам.

> Внешний доступ (из других категорий) к внутренним ресурсам категории разрешён *только* через модули **в корне** категории.
> 
> Все ресурсы, которые планируется использовать *извне* (импортировать в других категориях), должны *реэкспортироваться* в этих модулях.
> 
> Это ограничение формирует **явные** точки входа в категорию и обеспечивает **сокрытие** внутренних ресурсов.

Поэтому создадим в корне категории модуль `init-app.js`, в котором импортируем модуль `effects/init-app.js`.

> ```
> src
> |--app
>    |-- components
>    |   |-- app
>    |       |-- component.jsx
>    |       |-- index.js
>    |-- effects
>    |   |-- init-app.js
>    |-- init-app.js
> ```

Теперь мы можем указать путь к модулю `src/app/init-app.js` в сборщике, дело сделано! 🎉

#### Начинаем работу над домашней страницей

Совместно с менеджером мы решили, что из бизнес-функций стоит начать с реализации домашней страницы.

Мы только что инициализировали проект, поэтому нам потребуется проделать некоторую подготовительную работу. 

Кроме того, это комплесная задача, поэтому мы разделим её на несколько более простых.

- Изучив макеты, мы понимаем, что на домашней странице используются общие для всего проекта элементы, такие как изображения профиля, кнопки, ссылки, всплывающие окна. Они входят в разработанный дизайнерами UI-кит, у нас есть его макеты и документация. 

  Попробуем начать с реализации **UI-кита**. Чтобы это не заняло много времени, реализуем минимальный набор элементов и состояний, который нам необходим.

- Затем перейдём к реализации общего для страниц компонента **`Layout`**, который будет отвечать за раскладку содержимого и отрисовку общих элементов - лого, навигации, ссылки на профиль и на информацию о платформе.

- На главной странице есть бизнес-функции, которые впоследствии будут использоваться на других страницах - **посты**, **редактор постов** и **тренды**. Заведём для них отдельные категории.

- Соберём всё воедино!

Приступим! 👩‍🔧

#### Создаём UI-кит и компонент `Layout`

> *Здесь мы знакомимся с разными вариантами реэкспорта ресурсов из категорий и примерами импорта в других категориях.*

Приступим к разработке UI-кита и компонента `Layout`.

Создадим категорию `ui-kit`, в ней группу `components`. В ней создадим элементы `button`, `link`, `popover`, `profile-image`.

У категорий есть ограничение на досуп к внутренним ресурсам, поэтому создадим в корне модули, которые будут реэкспортировать нужные компоненты.

```
src
|-- ui-kit
|   |-- components
|   |   |-- button
|   |   |   |-- component.jsx
|   |   |   |-- index.js
|   |   |   |-- styles.js
|   |   |-- link
|   |   |   |-- component.jsx
|   |   |   |-- index.js
|   |   |   |-- styles.js
|   |   |-- popover
|   |   |   |-- component.jsx
|   |   |   |-- index.js
|   |   |   |-- styles.js
|   |   |-- profile-picture
|   |       |-- component.jsx
|   |       |-- index.js
|   |       |-- styles.js
|   |-- button.js
|   |-- link.js
|   |-- popover.js
|   |-- profile-image.js
|-- ...
```

Для примера, импорт компонента `ProfileImage` в компонентах других категорий будет выглядеть так:

```js
import ProfileImage from '../../../ui-kit/profile-image';
```

Минимальная реализация UI-кита готова! 🎉

Теперь займёмся компонентом `Layout`.

Создадим категорию `layout`. В ней группу `components` с элементами `layout`, а также `about`, `logo`, `navigation`, `profile`.

Также создадим группу `helpers` с элементами `scroll.js` и `window.js`. Эти хелперы будут нам полезны.

Основной элемент этой категории — `layout`. Чтобы избежать дублирования имени при импорте (`layout/layout`), реэкспортируем `layout` в индексном модуле (`index.js`).

```
src
|-- layout
|   |-- components
|   |   |-- about
|   |   |   |-- component.jsx
|   |   |   |-- index.js
|   |   |   |-- styles.js
|   |   |-- layout
|   |   |   |-- component.jsx
|   |   |   |-- index.js
|   |   |   |-- styles.js
|   |   |-- logo
|   |   |   |-- component.jsx
|   |   |   |-- index.js
|   |   |   |-- styles.js
|   |   |-- navigation
|   |   |   |-- component.jsx
|   |   |   |-- index.js
|   |   |   |-- styles.js
|   |   |-- profile
|   |       |-- component.jsx
|   |       |-- index.js
|   |       |-- styles.js
|   |-- helpers
|   |   |-- scroll.js
|   |   |-- window.js
|   |-- index.js
|-- ...
```

Для примера, импорт компонента `Layout` в компонентах других категории будет выглядеть так:

```js
import Layout from '../../../layout';
```

Успех! 🎉

#### Создаём компонент `Post`

> *Здесь мы создаём первую **подгруппу** и знакомимся с ограничением на **доступ к ресурсам подгрупп**.*

Для компонента `Post` создадим категорию `post`.

```
# здесь и далее структура компонентов упрощена

src
|-- post
|   |-- components
|   |   |-- content
|   |   |   |-- ...
|   |   |-- image
|   |   |   |-- ...
|   |   |-- like
|   |   |   |-- ...
|   |   |-- post
|   |   |   |-- ...
|   |   |-- reply
|   |   |   |-- ...
|   |   |-- repost
|   |   |   |-- ...
|   |   |-- share
|   |   |   |-- ...
|   |   |-- text
|   |   |   |-- ...
|   |   |-- video
|   |   |   |-- ...
|   |   |-- views
|   |       |-- ...
|   |-- index.js
|-- ...
```

Давайте изучим получившийся список компонентов. В нём можно выделить две подгруппы:

- `content` — с компонентами, которые отвечают за отрисовку контента,
- `actions` — с компонентами, которые отвечают за отрисовку действий с постом.

Дополнительная группировка помогает лучше понимать назначение элементов. Поэтому, в данном случае создадим [подгруппы](#подгруппы) `components#content` и `components#actions`.

> Группы могут иметь подгруппы. Подгруппа — это директория, которая применяется для **дополнительной группировки элементов группы**.
> 
> Имя подгруппы имеет структуру: `<имя группы>#<имя подгруппы>`.
> 
> Подгруппа отличается от обычной группы наличием **связи с родительскими группами** (одной или несколькими) и связанным с этим **ограничением на доступ к ресурсам**.

```
src
|-- post
|   |-- components
|   |   |-- post
|   |   |   |-- ...
|   |   |-- views
|   |       |-- ...
|   |-- components#actions
|   |   |-- like
|   |   |   |-- ...
|   |   |-- reply
|   |   |   |-- ...
|   |   |-- repost
|   |   |   |-- ...
|   |   |-- share
|   |       |-- ...
|   |-- components#content
|   |   |-- content
|   |   |   |-- ...
|   |   |-- image
|   |   |   |-- ...
|   |   |-- text
|   |   |   |-- ...
|   |   |-- video
|   |       |-- ...
|   |-- index.js
|-- ...
```

Существует [ограничение](#ограничения-групп) на доступ к ресурсам подгрупп:

> Доступ к ресурсам подгрупп разрешён только из **родительских групп** и **групп с другим именем** (например, из `components` к `helpers#math`). Доступ в **подгруппах** к ресурсам **родительских групп** *запрещён*.
>
> Это ограничение структурирует **связи** между группами и подгруппами и позволяет избежать **циклических зависимостей**.
>
> Если к ресурсам *необходимо* иметь доступ одновременно в родительской группе и всех её подгруппах, необходимо расположить их в [мета-группе](#мета-группы) @shared.

Мы свободно можем обращаться в `components` к ресурсам `components#actions` и `components#content`, но не наоборот.

Успех! 🎉

#### Усложняем `Post`, добавляем новую бизнес-функцию — полноэкранный просмотр изображений

> *Здесь мы создаём первую **подкатегорию**, **мета-категорию** и знакомимся с их особенностями и ограничениями.*

Компонент отображения поста — это комплексная бизнес-функция. Её можно разбить на более простые бизнес-функции, например, полноэкранный просмотр изображений, прикреплённых к посту.

Бизнес-функция полноэкранного просмотра является обособленной, но не может существовать в отрыве от основной бизнес-функции. В этом случае для лучшей группировки стоит разделить их, но явно обозначить между ними связь.

Для этого создадим [подкатегорию](#подкатегории) `post.image-viewer`.

> Категории могут иметь подкатегории. Подкатегория — это директория, которая применяется для **декомпозиции комплексных бизнес-функций**. 
> 
> Например, когда одну **комплексную** бизнес-функцию будет удачнее разбить на несколько **простых**.
> 
> Подкатегория отличается от обычной категории наличием **связи с родительскими категориями** (одной или несколькими) и связанным с этим **ограничением на доступ к ресурсам**.

```
src
|-- post
|   |-- ...
|
|-- post.image-viewer
|   |-- components
|   |   |-- backdrop
|   |   |   |-- ...
|   |   |-- navigation
|   |   |   |-- ...
|   |   |-- viewer
|   |       |-- ...
|   index.js
|
|-- ...     
```

В бизнес-функции полноэкранного просмотра дублируются действия с постом - лайк, репост, реплай, поделиться.

Мы уже реализовали соответствующие компоненты в категории `post` и могли бы обратиться к ним, но нужно учесть следующее: у подкатегорий существует [ограничение](#ограничения-категорий) на доступ к ресурсам родительских категорий.

> Доступ в **подкатегориях** к ресурсам **родительских категорий** *запрещён*.
> 
> Это ограничение структурирует **связи** между категориями и подкатегориями и позволяет избежать **циклических зависимостей**.

Таким образом, мы не можем обратиться в подкатегории `post.image-viewer` к ресурсам родительской категории `post`.

Но есть решение — создать [мета-категорию](#мета-категории) `post@shared`.

> Мета-категория отличается от обычной категории тем, что:
>
> - доступ к ресурсам мета-категории разрешён в **базовой категории** (без мета-тега) и всех её **подкатегориях** — и только в них,
> 
> - в **мета-категории** *запрещён* доступ к ресурсам **базовой категории** и всех её **подкатегорий**,
> 
> - мета-категория может **переопределять** ограничения обычных категорий.
> 
> Имя имеет структуру: `<имя базовой категории>@<мета-тег>`.
>
> В мета-категории @shared **не действует** ограничение на прямой доступ к внутренним ресурсам, можно обращаться к ресурсам *напрямую*.

Создадим мета-категорию `post@shared` и перенесём в неё группу `components#actions`.

```
src
|-- post
|   |-- components
|   |   |-- post
|   |   |   |-- ...
|   |   |-- views
|   |       |-- ...
|   |-- components#content
|   |   |-- content
|   |   |   |-- ...
|   |   |-- image
|   |   |   |-- ...
|   |   |-- text
|   |   |   |-- ...
|   |   |-- video
|   |       |-- ...
|   |-- index.js
|
|-- post.image-viewer
|   |-- components
|   |   |-- backdrop
|   |   |   |-- ...
|   |   |-- navigation
|   |   |   |-- ...
|   |   |-- viewer
|   |       |-- ...
|   index.js
|
|-- post@shared
|   |-- components#actions
|       |-- like
|       |   |-- ...
|       |-- reply
|       |   |-- ...
|       |-- repost
|       |   |-- ...
|       |-- share
|           |-- ...
|
|-- ...
```

Теперь мы можем обратиться к ресурсам группы `components#actions` мета-категории `post@shared` как в категории `post`, так и в `post.image-viewer`.

Успех! 🎉

#### Создаём компоненты `PostEditor` и `TrendsWidget`

Для компонента `PostEditor` создадим категорию `post-editor`. 

В `PostEditor` есть пикер emoji, который будет использоваться в нескольких других местах, поэтому отделим его и создадим категорию `emoji`.

```
src
|-- emoji
|   |-- components
|   |   |-- picker
|   |       |-- ...
|   |-- values
|   |   |-- emoji-map.js
|   |-- picker.js
|
|-- post-editor
|   |-- components
|   |   |-- audience
|   |   |   |-- ...
|   |   |-- editor
|   |   |   |-- ...
|   |   |-- emoji
|   |   |   |-- ...
|   |   |-- media
|   |   |   |-- ...
|   |   |-- poll
|   |   |   |-- ...
|   |   |-- settings
|   |   |   |-- ...
|   |   |-- text-area
|   |       |-- ...
|   |-- values
|   |   |-- post-limits.js
|   |-- index.js
|
|-- ...
```

Для компонента `TrendsWidget` — категорию `trends`.

```
src
|-- trends
|   |-- components
|   |   |-- trends-widget
|   |       |-- ...
|   |-- trends-widget.js
|-- ...
```

Приближаемся к финишу! 🏁

#### Объединяем вместе компоненты домашней страницы

Осталось реализовать домашнюю страницу и соединить вместе компоненты, которые мы реализовали ранее.

Чтобы подготовить компоненты для показа на главной странице, их нужно декорировать.

Создадим категорию `home`. В ней создадим компонент `PostEditor`. В коде компонента импортируем компонент `PostEditor` из категории `post-editor` и добавим необходимую дополнительную логику, стили.

Похожим образом релизуем другие локальные компоненты — `PostFeed` и `Trends`.

Объединим получившиеся компоненты в компоненте `Home`.

```
src
|-- home
|   |-- components
|   |   |-- home
|   |   |   |-- ...
|   |   |-- post-editor
|   |   |   |-- ...
|   |   |-- post-feed
|   |   |   |-- ...
|   |   |-- trends
|   |       |-- ...
|   |-- index.js
|-- ...
```

После этого обновим код корневого компонента `App` и внедрим в него компонент `Home`.

Теперь развернём приложение на стейдже и уведомим об этом QA-инженера. После некоторого времени, он одобрил наши изменения.

Минимальная реализация домашней страницы закончена! 🎉 

#### Гордимся собой 🤗

Поздравляю, вы изучили **Sliced Design** на 90%. Структурируйте свои знания о категориях, группах и элементах, изучив [методологию](#методология), и начните применять **Sliced Design** в своих проектах! ✌️

### Пример проекта

Посмотреть пример файловой структуры проекта можно на [CodeSandbox](https://codesandbox.io/s/sliced-design-react-v1-irwu2s).

⬆️ [К содержанию](#содержание)

## Методология

### Категория

Категория — директория, которая применяется для группировки [элементов](#элемент) **по бизнес-функции**.

Создаёт новое пространство имён.

> ```
> # в примере ниже `layout` - категория
>
> src
> |-- layout
> |   |-- components
> |   |   |-- ...
> |   |-- helpers
> |   |   |-- ...
> |   |-- index.js
> |-- ...
> ```

#### Расположение категорий

Категории располагаются в директории `src` и только в ней.

#### Подкатегории

Категории могут иметь подкатегории. Подкатегория — это директория, которая применяется для **декомпозиции комплексных бизнес-функций**. 

Например, когда одну **комплексную** бизнес-функцию будет удачнее разбить на несколько **простых**.

Создаёт новое пространство имён.

Подкатегория отличается от обычной категории наличием **связи с родительскими категориями** (одной или несколькими) и связанным с этим **ограничением на доступ к ресурсам**.

Связь выражается на уровне **имени** директории, через *перечисление цепочки имён родительских категорий через точку*.

> ```
> # в примере ниже `post.image-viewer` - подкатегория `post`
>
> src
> |-- post
> |   |-- components
> |   |   |-- ...
> |   |-- components#content
> |   |   |-- ...
> |   |-- index.js
> |
> |-- post.image-viewer
> |   |-- components
> |   |   |-- ...
> |   |-- index.js
> |
> |-- ...
> ```

#### Ограничения категорий

- Внешний доступ (из других категорий) к внутренним ресурсам категории разрешён *только* через модули **в корне** категории.

  Все ресурсы, которые планируется использовать *извне* (импортировать в других категориях), должны *реэкспортироваться* в этих модулях.

  Это ограничение формирует **явные** точки входа в категорию и обеспечивает **сокрытие** внутренних ресурсов.

  Пример:

  > <code>src/<b>post-editor</b>/components/emoji/component.jsx</code>:
  >
  > ```js
  > // ✅ так можно
  >
  > import { Picker } from '../../../emoji';
  >
  > // ✅ так можно
  >
  > import Picker from '../../../emoji/picker';
  >
  > // ❌ так нельзя, категория `post-editor` не имеет доступ к внутренним ресурсам категории `emoji`
  >
  > import Picker from '../../../emoji/components/picker';
  > ```

- Доступ к ресурсам подкатегорий разрешён только из **родительских категорий** и **категорий с другим именем** (например, из `app` к `post.image-viewer`). Доступ в **подкатегориях** к ресурсам **родительских категорий** *запрещён*.

  Это ограничение структурирует **связи** между категориями и подкатегориями и позволяет избежать **циклических зависимостей**.

  > Если к ресурсам *необходимо* иметь доступ одновременно в родительской категории и всех её подкатегориях, необходимо расположить их в [мета-категории](#мета-категории) @shared.

  Пример:

  > <code>src/<b>post</b>/components/post/component.jsx</code>:
  >
  > ```js
  > // ✅ так можно
  >
  > import ImageViewer from '../../../post.image-viewer';
  > ```
  >
  > <code>src/<b>post.image-viewer</b>/components/viewer/component.jsx</code>:
  >
  > ```js
  > // ❌ так нельзя, подкатегория `post.image-viewer` не имеет доступ к ресурсам родительской категории `post`
  >
  > import Like from '../../../post/like';
  >
  > // ✅ но так можно
  >
  > import Like from '../../../home@shared/components#actions/like';
  > ```

#### Мета-категории

Мета-категория отличается от обычной категории тем, что:

- доступ к ресурсам мета-категории разрешён в **базовой категории** (без мета-тега) и всех её **подкатегориях** — и только в них,

- в **мета-категории** *запрещён* доступ к ресурсам **базовой категории** и всех её **подкатегорий**,

- мета-категория может **переопределять** ограничения обычных категорий.

Имя имеет структуру: `<имя базовой категории>@<мета-тег>`.

> Если базовая категория не указана, доступ к мета-категории считается разрешёным *во всём проекте*.

- **@shared**

  Мета-категория @shared применяется для хранения ресурсов, к которым необходимо иметь доступ *одновременно* в **родительской категории** и всех её **подкатегориях**.

  Переопределяет ограничения:

  - в мета-категории @shared **не действует** ограничение на прямой доступ к внутренним ресурсам, можно обращаться к ресурсам *напрямую*
  <br />

  > Доступ к ресурсам мета-категории `@shared` (без указания базовой категории) разрешён во всём проекте.

  Пример:

  > <code>src/<b>post</b>/components/post/component.jsx</code>:
  >
  > ```js
  > // ✅ так можно
  >
  > import Share from '../../../post@shared/components#actions/share';
  > ```
  >
  > <code>src/<b>home</b>/components/post-feed/component.jsx</code>:
  >
  > ```js
  > // ❌ так нельзя, категория `home` не имеет доступ к ресурсам мета-категории `post@shared`
  >
  > import Share from '../../../post@shared/components#actions/share';
  > ```

⬆️ [К содержанию](#содержание)

### Группа

Группа — директория, которая применяется для группировки [элементов](#элемент) **по типу**. 

Создаёт новое пространство имён.

> ```
> # в примере ниже `components` - группа
>
> src
> |-- layout
> |   |-- components
> |   |   |-- about
> |   |   |   |-- ...
> |   |   |-- layout
> |   |   |   |-- ...
> |   |   |-- logo
> |   |   |   |-- ...
> |   |   |-- navigation
> |   |   |   |-- ...
> |   |   |-- profile
> |   |       |-- ...
> |   |-- ...
> |-- ...
> ```

#### Расположение групп

Группы располагаются внутри категорий и только в них.

#### Подгруппы

Группы могут иметь подгруппы. Подгруппа — это директория, которая применяется для **дополнительной группировки элементов группы**.

Создаёт новое пространство имён.

Имя подгруппы имеет структуру: `<имя группы>#<имя подгруппы>`.

Подгруппа отличается от обычной группы наличием **связи с родительскими группами** (одной или несколькими) и связанным с этим **ограничением на доступ к ресурсам**.

Связь выражается на уровне **имени** подгруппы, через *перечисление цепочки имён родительских групп через точку*.

> ```
> # в примере ниже `components#content` - подгруппа `components`
>
> src
> |-- post
> |   |-- components
> |   |   |-- ...
> |   |-- components#content
> |   |   |-- ...
> |   |-- ...
> |-- ...
> ```

#### Ограничения групп

- Доступ к ресурсам подгрупп разрешён только из **родительских групп** и **групп с другим именем** (например, из `components` к `helpers#math`). Доступ в **подгруппах** к ресурсам **родительских групп** *запрещён*.

  Это ограничение структурирует **связи** между группами и подгруппами и позволяет избежать **циклических зависимостей**.

  > Если к ресурсам *необходимо* иметь доступ одновременно в родительской группе и всех её подгруппах, необходимо расположить их в [мета-группе](#мета-группы) @shared.

  Пример:

  > <code>src/post/<b>components</b>/post/component.js</code>:
  >
  > ```js
  > // ✅ так можно
  >
  > import Content from '../components#content/content';
  > ```
  >
  > <code>src/post/<b>components#content</b>/text/component.js</code>:
  >
  > ```js
  > // ❌ так нельзя, подгруппа `components#content` не имеет доступ к ресурсам родительской группы `components`
  >
  > import ProfilePopover from '../components/profile-popover';
  >
  > // ✅ но так можно
  >
  > import ProfilePopover from '../components@shared/profile-popover';
  > ```

#### Мета-группы

Мета-группа отличается от обычной группы тем, что:

- доступ к ресурсам мета-группы разрешён в **базовой группе** (без мета-тега) и всех её **подгруппах** — и только в них,

- в **мета-группе** *запрещён* доступ к ресурсам **базовой группы** и всех её **подгрупп**,

- мета-группа может **переопределять** ограничения обычных групп.

Имя имеет структуру: `<имя базовой группы>@<мета-тег>`.

- **@shared**

  Мета-группа @shared применяется для хранения ресурсов, к которым необходимо иметь доступ *одновременно* в **родительской группе** и всех её **подгруппах**.

  *Не переопределяет ограничения*.

  Пример:

  > <code>src/post/<b>helpers</b>/playback.js</code>:
  >
  > ```js
  > // ✅ так можно
  >
  > import math from '../../helpers@shared/math';
  >
  > ```
  > <code>src/post/<b>components#content</b>/video/component.js</code>:
  >
  > ```js
  > // ❌ так нельзя, группа `components#content` не имеет доступ к ресурсам мета-группы `helpers@shared`
  >
  > import math from '../../helpers@shared/math';
  > ```

⬆️ [К содержанию](#содержание)

### Элемент

Элемент — модуль или директория с модулями, которые экспортируют [ресурсы](#ресурс).

> ```
> # в примере ниже `scroll.js` - элемент
>
> src
> |-- layout
> |   |-- helpers
> |   |   |-- scroll.js
> |   |   |-- ...
> |   |-- ...
> |-- ...
> ```
>
> ```
> # в примере ниже `navigation` - элемент
>
> src
> |-- layout
> |   |-- components
> |   |   |-- navigation
> |   |   |   |-- component.jsx
> |   |   |   |-- index.js
> |   |   |   |-- styles.js
> |   |   |-- ...
> |   |-- ...
> |-- ...
> ```

#### Расположение элементов

Элементы располагаются внутри групп и только в них.

#### Связи модулей внутри элемента-директории

Модули внутри элемента-директории могут иметь связи. Связь родительского модуля и потомка выражается на уровне **имени** модуля, через *перечисление цепочки имён родительских модулей через точку*.

> ```
> в примере ниже модуль `styles.actions.js` связан с модулем `styles.js`
>
> src
> |-- post-editor
>     |-- components
>         |-- editor
>             |-- component.jsx
>             |-- index.js
>             |-- styles.js
>             |-- styles.actions.js
> ```

На уровне имён можно реализовать виртуальную директорию:

> ```
> в примере ниже реализована виртуальная директория `assets`
>
> src
> |-- post-editor
>     |-- components
>         |-- editor
>             |-- assets.emoji-icon.svg
>             |-- assets.media-icon.svg
>             |-- assets.poll-icon.svg
>             |-- component.jsx
>             |-- index.js
>             |-- styles.js
> ```

#### Ограничения элементов

- Внешний доступ к внутренним ресурсам элемента-директории разрешён *только* через индексный модуль (`index.js`).

  Все ресурсы, которые планируется использовать *извне* (импортировать в других элементах, группах, категориях), должны *реэкспортироваться* в индексном модуле.

  Это ограничение формирует **явную** точку входа в элемент и обеспечивает **сокрытие** внутренних ресурсов.

  Пример:

  > <code>src/post-editor/components/<b>editor</b>/component.jsx</code>:
  >
  > ```js
  > // ✅ так можно
  >
  > import Media from '../media';
  >
  > // ❌ так нельзя, элемент `editor` не имеет доступ к внутренним ресурсам элемента `media`
  >
  > import mediaIcon from '../media/assets.media-icon.svg';
  > ```

⬆️ [К содержанию](#содержание)

### Ресурс

Ресурс — любое значение, экспортируемое из модуля.

```jsx
// в примере ниже `Component`, `mathHelper` и `meaningOfLife` - ресурсы

export const Component = () => {
  return <span>Hello, world!<span/>;
}

export const mathHelper = (r) => {
  return Math.PI * r**2;
};

export const meaningOfLife = () => {
  return wait('7.5m years').then(() => 42);
};
```

⬆️ [К содержанию](#содержание)

### Общие рекомендации

- Избегайте циклических зависимостей.
- Для именования директорий и файлов используйте kebab-case.

## FAQ

**Можно ли использовать Sliced Design с TypeScript?**

Да!

**Можно ли использовать Sliced Design с CommonJS?**

Да! Только синтаксис модулей будет отличаться.

**Можно ли использовать Sliced Design с другими языками?**

Полагаю, что да! Если у вас получится, пожалуйста, поделитесть опытом.

## Обратная связь

Буду рад любой обратной связи! Пожалуйста, пишите в discussions или issues.

## Контрибьюторы

Ведущий разработчик — [@austrokhart](https://github.com/austrokhart).

Идеи:
- [@daryabratova](https://github.com/daryabratova)
- [@a1ex-kaufmann](https://github.com/a1ex-kaufmann)
- [@kindaro](https://github.com/kindaro)

## Поддержать автора

Я потратил сотню часов, работая над этим проектом. Надеюсь, что он сэкономит тысячи часов времени другим разработчикам во время работы над их проектами.

Если хотите, можете поддержать меня на [Boosty](https://boosty.to/austrokhart).
